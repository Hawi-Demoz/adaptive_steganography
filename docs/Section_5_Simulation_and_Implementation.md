5. Simulation and Implementation

This section documents the simulation workflow used to evaluate the adaptive audio steganography system, focusing on **(i) energy adaptivity level** and **(ii) secret message length** and how each changes the observed waveform differences and quantitative metrics.

5.1 Simulation Environment

Description of tools used
- **Python (offline simulation)**: The system is implemented and evaluated using offline WAV processing (no MATLAB/Simulink or hardware-in-the-loop).
- **NumPy**: vectorized array processing; bit packing/unpacking; deterministic RNG behavior.
- **SoundFile**: WAV I/O with `int16` PCM fidelity.
- **Matplotlib**: generation of waveform comparison plots and noise/SNR plots.
- **PyCryptodome**: AES encryption/decryption (AES-CBC with PKCS#7 padding) when `encrypt=True`.

Justification for tool selection
- Python provides a reproducible DSP simulation environment with fast iteration and easy instrumentation.
- NumPy + SoundFile allow precise `int16`-domain operations (important for LSB replacement).
- Matplotlib produces publication-ready figures directly into `figures/run_*` folders.
- PyCryptodome provides a standard cryptographic primitive so the thesis can focus on steganographic design (not custom crypto).

5.2 Model Development

Step-by-step process for model creation

Step 1 — Payload framing
- The embedded bitstream is: `ASTG` preamble (4 bytes) + payload length (4 bytes, big-endian) + payload bytes.
- Header size is fixed at 8 bytes = 64 bits.

Step 2 — Optional encryption (confidentiality)
- If enabled, the payload is encrypted using AES-CBC with PKCS#7 padding.
- Encrypted payload includes a random 16-byte IV: `payload = IV || ciphertext`.

Step 3 — Energy-based content analysis (adaptivity)
- Audio is segmented into overlapping frames (`frame_size`, `hop_size`).
- Frame energy uses RMS:

  $$\mathrm{RMS}(k) = \sqrt{\frac{1}{N_k}\sum_{n\in k} x[n]^2}$$

- RMS values are normalized to a score in $[0,1]$. Frames below `energy_percentile` are strongly de-prioritized.

Important implementation detail (ordering stability)
- Energy is computed on `x & ~1` (LSB cleared) so the ordering does not drift between cover and stego.

Step 4 — Keyed deterministic ordering (where embedding happens)
- A deterministic RNG is seeded from the user key (SHA-256 based).
- For each sample $n$, a random value $r[n] \sim U(0,1)$ is generated.
- Each sample inherits a frame score `score[n]` from the frame it belongs to.
- Samples are ranked by:

  $$\mathrm{ord\_key}[n] = \frac{r[n]}{\mathrm{score}[n] + \epsilon}$$

  Smaller values are embedded earlier. A stable sort ensures the ordering is prefix-stable.

Step 5 — LSB embedding (time-domain)
- For each selected sample index $i$ and next payload bit $b \in \{0,1\}$:

  $$y[i] = (x[i] \ \&\ \sim 1)\ \vert\ b$$

Step 6 — Extraction
- The same ordering is recomputed using the same key and parameters.
- First 64 bits decode `ASTG + length`, then the payload is read.
- If encryption is enabled, AES decryption is applied to recover plaintext.

5.3 Simulation Setup and Configuration

Input parameters and assumptions
- Cover audio: `data/original/sample.wav` (mono used; if stereo, the first channel is used).
- Cover length: **262,094 samples** at **44.1 kHz** (duration $\approx$ **5.94 s**).
- Sample type: `int16` PCM.

Core configuration (default)
- `frame_size = 1024` samples
- `hop_size = 512` samples
- `energy_percentile \in \{0, 20, 40\}` (used as “energy adaptivity level”)
- Secret message length: `message_len_bytes \in \{16, 256, 2048\}`

Simulation sweep design
- The reproducible sweep is implemented in `src/sweep_experiments.py` and writes:
  - `figures/run_YYYYMMDD_HHMMSS/sweep_results.csv`
  - `figures/run_YYYYMMDD_HHMMSS/sweep_results.md`
  - waveform plots `waveform_*.png`
  - noise/SNR plots `snr_noise_*.png`

Boundary conditions
- `int16` range: samples are constrained to $[-32768, 32767]$.
- LSB embedding guarantees `max_abs_diff = 1` (the waveform difference is bounded by 1 quantization step).
- Successful extraction requires matching: `frame_size`, `hop_size`, `energy_percentile`, and the correct key.

How to run the simulation
- Parameter sweep (energy level × message length):

  ```powershell
  python -m src.sweep_experiments
  ```

- Interactive embed/extract with metrics:

  ```powershell
  python -m src.sim_cli
  ```

5.4 Results and Analysis

Presentation of key results (tables/figures)

All results below were generated by the sweep run:
- `figures/run_20260126_122629/sweep_results.md`
- Waveform comparison plots: `figures/run_20260126_122629/waveform_*.png`
- Noise/SNR plots: `figures/run_20260126_122629/snr_noise_*.png`

Summary table (energy adaptivity level vs. message length)

| energy_percentile | message_len_bytes | encrypt | bits_used_total | fraction_changed | snr_db | frac_mod_in_top_energy_frames | extraction_ok | payload_bit_ber |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0.000000 | 16 | False | 192 | 0.039% | 101.02 | 41.584% | True | 0.000000 |
| 0.000000 | 256 | False | 2112 | 0.396% | 91.24 | 42.775% | True | 0.000000 |
| 0.000000 | 2048 | False | 16448 | 3.098% | 82.34 | 45.961% | True | 0.000000 |
| 20.000000 | 16 | False | 192 | 0.035% | 101.43 | 43.956% | True | 0.000000 |
| 20.000000 | 256 | False | 2112 | 0.398% | 91.22 | 45.298% | True | 0.000000 |
| 20.000000 | 2048 | False | 16448 | 3.127% | 82.30 | 45.711% | True | 0.000000 |
| 40.000000 | 16 | False | 192 | 0.036% | 101.26 | 43.158% | True | 0.000000 |
| 40.000000 | 256 | False | 2112 | 0.436% | 90.82 | 48.164% | True | 0.000000 |
| 40.000000 | 2048 | False | 16448 | 3.153% | 82.26 | 47.326% | True | 0.000000 |
| 20.000000 | 256 | True | 2368 | 0.448% | 90.71 | 45.610% | True | 0.000000 |

Interpretation of results in the context of design objectives

Effect of secret message length (capacity vs. distortion)
- Increasing `message_len_bytes` increases the number of embedded bits, which increases how many samples are modified.
- The observed relationship matches the expected LSB behavior:
  - For random payload bits, about **50%** of the written LSBs differ from the cover LSBs.
  - Therefore, expected modified samples $\approx 0.5 \times \mathrm{bits\_used\_total}$.
- Example (energy_percentile = 0):
  - 16 B payload: 192 bits used → ~96 expected flips; observed fraction changed = 0.039%.
  - 256 B payload: 2112 bits used → ~1056 expected flips; observed fraction changed = 0.396%.
  - 2048 B payload: 16448 bits used → ~8224 expected flips; observed fraction changed = 3.098%.
- SNR decreases with longer payloads because more LSB changes raise the overall noise power:
  - ~101 dB (16 B) → ~91 dB (256 B) → ~82 dB (2048 B).
- Waveform difference interpretation:
  - In `waveform_*.png`, the cover and stego waveforms visually overlap.
  - The difference is bounded to ±1 LSB per modified sample (consistent with `max_abs_diff = 1`), so even at 2048 B the visible difference is small.

Effect of energy adaptivity level (where modifications occur)
- `energy_percentile` does **not** primarily control “how much” noise is added (payload length controls that); it controls **where** the changes concentrate.
- This is quantified by `frac_mod_in_top_energy_frames` (fraction of modified samples that fall in the top 20% highest-energy frames):
  - For 256 B payload, `frac_mod_in_top_energy_frames` increases from **42.8% (e=0)** to **48.2% (e=40)**.
- Practical interpretation in the plots:
  - In `snr_noise_*.png`, higher `energy_percentile` tends to concentrate the noise waveform in louder regions (better perceptual masking).
  - This supports the imperceptibility objective: modifications are placed where the human auditory system is less sensitive.

Effect of encryption (security overhead)
- For the 256 B reference case, enabling AES increases `bits_used_total` from **2112** to **2368** due to IV + padding overhead.
- The fraction changed increases accordingly (0.398% → 0.448%) with a small SNR decrease (91.22 dB → 90.71 dB).
- Extraction remains correct (`payload_bit_ber = 0`) when the correct key and matching parameters are used.

Low energy level case study (energy_percentile = 0.0)

This subsection records a complete end-to-end simulation run at the **low energy adaptivity setting** (no percentile thresholding). This is included to document the exact workflow, terminal outputs, and resulting metrics for the thesis.

Concepts and methods used
- **AES encryption (confidentiality):** plaintext is encrypted before embedding, so an attacker extracting LSBs only obtains ciphertext.
- **Key-based deterministic ordering (security):** embedding positions are generated by a key-seeded process, preventing sequential/predictable placement.
- **LSB embedding (time domain):** selected samples have their least significant bit replaced by payload bits.
- **Header framing:** `ASTG` preamble + 4-byte length enables the extractor to locate and read the correct payload size.

Simulation configuration
- Cover: `data/original/sample.wav` (PCM `int16`, 44.1 kHz)
- `frame_size = 1024`, `hop_size = 512`
- Energy adaptivity level: `energy_percentile = 0.0` (low)
- Encryption: enabled (AES-CBC + PKCS#7)
- Output: `data/stego/stego_low_energy.wav`
- Figures: `figures/run_20260126_130832/`

Terminal record (embedding + extraction)

```text
============================================================
Low Energy Level Simulation (energy_percentile = 0.0)
============================================================
Cover WAV: data\original\sample.wav
Output stego WAV: data\stego\stego_low_energy.wav
Figures directory: figures\run_20260126_130832

[Embedding Inputs]
Secret message (UTF-8): LOW-ENERGY TEST: This message is embedded using keyed adaptive LSB (energy_percentile=0) with AES encryption enabled.
Secret message length: 117 bytes
Encryption: ENABLED (AES-CBC + PKCS#7)
Key-based random embedding: ENABLED (SHA-256 seeded ordering)
Energy-adaptive embedding: ENABLED (energy_percentile=0.0)
Embedded (adaptive+keyed) 144 bytes into data\stego\stego_low_energy.wav (samples used: 1216)

[Payload Accounting]
Ciphertext length (IV + CT): 144 bytes
Header length: 8 bytes (ASTG + payload length)
Bits used (header + ciphertext): 1216
Estimated flips (~50% of used bits): 608
Actual flips (LSB changed): 613 / 262094 (0.2339%)
Extracted payload of length 144 bytes (adaptive+keyed).

[Performance Metrics]
SNR (cover vs stego): 93.50 dB
LSB BER (cover vs stego): 0.002339
Payload BER (recovered vs original): 0.000000

[Extraction Result]
Extraction OK: True
Recovered message (UTF-8): LOW-ENERGY TEST: This message is embedded using keyed adaptive LSB (energy_percentile=0) with AES encryption enabled.
```

Results interpretation
- **Message recovery:** the recovered message matches the original (Extraction OK = True, payload BER = 0), demonstrating correct operation when parameters/key match.
- **Waveform difference magnitude:** because only the LSB is modified, the maximum per-sample amplitude change is bounded to **±1 LSB unit**; this is visualized in `low_energy_waveform.png`.
- **Distortion vs. payload size:** ciphertext expansion (IV + padding) increased payload size from **117 bytes** plaintext to **144 bytes** ciphertext, increasing the number of embedded bits (1216 total including header).
- **Imperceptibility metrics:** SNR of **93.50 dB** indicates the introduced noise is low relative to the signal; LSB BER of **0.002339** reflects the fraction of samples whose LSB changed compared to the cover.

Figures produced for this run
- `figures/run_20260126_130832/low_energy_waveform.png`
- `figures/run_20260126_130832/low_energy_snr_noise.png`
- `figures/run_20260126_130832/low_energy_spectrogram.png`
- `figures/run_20260126_130832/low_energy_lsb_heatmap.png`

Limitations / notes
- This section evaluates imperceptibility and correct extraction in the noiseless case. The current implementation improves **security** (AES + key-based ordering) and **imperceptibility** (energy adaptivity), but **true robustness to MP3/AAC compression and resampling is not fully addressed yet**.

Practical methods to improve robustness (recommended roadmap)

1) Add error-control coding (ECC) + interleaving (best “first upgrade”)
- Apply an ECC to the encrypted payload before embedding (e.g., BCH / Reed–Solomon / LDPC) and interleave bits across time.
- Why it helps: small bit errors caused by mild processing/noise become correctable, improving extraction reliability without changing the audio model.
- Expected impact: improves robustness to AWGN, mild filtering, and small perturbations; limited improvement for heavy lossy compression unless combined with transform-domain embedding.

2) Add synchronization + resampling tolerance
- Introduce a strong sync header/pilot sequence repeated periodically (not just a single preamble at the beginning).
- Use correlation to re-find payload start after trimming, time-shift, or small speed changes.
- Why it helps: resampling/time-scale changes break sample-aligned LSB indexing; synchronization makes extraction possible even when alignment drifts.

3) Move from time-domain LSB to transform-domain embedding (needed for MP3-style robustness)
- MP3/AAC operate in a transform domain (MDCT-like). To survive them, embed into features that remain stable after quantization:
  - STFT magnitude-bin embedding (mid-frequency bands)
  - Wavelet/DWT coefficient embedding
  - MDCT/cepstral feature embedding (more aligned with perceptual codecs)
- Use quantization-based schemes such as QIM:
  $$c' = Q_\Delta(c, b)$$
  where $c$ is a transform coefficient, $b$ is the bit, and $Q_\Delta$ enforces one of two quantizers.

4) Use spread-spectrum / redundancy across frames
- Spread each payload bit across many coefficients/samples (direct-sequence spread spectrum), then recover via correlation.
- Why it helps: lossy compression behaves like noise + quantization; spreading makes the bit decision more robust at the cost of capacity.

5) Perceptual masking model (stronger adaptivity)
- Replace simple RMS gating with a psychoacoustic masking estimate (critical bands, masking thresholds).
- Why it helps: allows stronger embedding where it is perceptually hidden, enabling more redundancy/ECC without audible artifacts.

6) Integrity/authentication (robustness against tampering)
- Add a keyed MAC (or AEAD like AES-GCM) over the plaintext before embedding.
- Why it helps: prevents undetected modification; complements confidentiality.

Summary
- Your current “AES + keyed random positions + energy adaptivity” already fixes the major weaknesses of *traditional sequential plaintext LSB* (security, predictability, and perceptual quality).
- To claim robustness against compression/resampling in the thesis, the key technical step is: **add ECC + synchronization** and, for MP3/AAC, **switch to transform-domain (QIM/spread-spectrum) embedding**.
